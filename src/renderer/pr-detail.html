<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' http://localhost:*; img-src 'self' https:">
  <title>PR Details</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --text-primary: #f0f6fc;
      --text-secondary: #8b949e;
      --accent: #58a6ff;
      --accent-hover: #79b8ff;
      --success: #3fb950;
      --warning: #d29922;
      --error: #f85149;
      --border: #30363d;
      --diff-add-bg: rgba(46, 160, 67, 0.15);
      --diff-add-text: #3fb950;
      --diff-del-bg: rgba(248, 81, 73, 0.15);
      --diff-del-text: #f85149;
      --diff-hunk-bg: rgba(56, 139, 253, 0.1);
      --diff-hunk-text: #58a6ff;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 14px;
      line-height: 1.5;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    /* Header */
    .detail-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .back-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 13px;
    }
    
    .back-btn:hover {
      background: var(--border);
    }
    
    .header-title {
      flex: 1;
      font-size: 16px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .header-actions {
      display: flex;
      gap: 8px;
    }
    
    .icon-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
    }
    
    .icon-btn:hover {
      background: var(--border);
      color: var(--text-primary);
    }
    
    /* Content */
    .detail-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    /* Meta */
    .detail-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    .meta-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--bg-tertiary);
    }
    
    .meta-author {
      font-weight: 500;
      color: var(--text-primary);
    }
    
    .meta-separator {
      color: var(--text-secondary);
    }
    
    .meta-repo {
      color: var(--accent);
    }
    
    .meta-time {
      color: var(--text-secondary);
    }
    
    .meta-labels {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    
    .label {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
    }
    
    /* Section */
    .section {
      margin-bottom: 24px;
    }
    
    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .section-stats {
      font-weight: 400;
      color: var(--text-secondary);
      font-size: 13px;
    }
    
    .stats-add {
      color: var(--success);
    }
    
    .stats-del {
      color: var(--error);
    }
    
    /* Description */
    .description-content {
      padding: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      white-space: pre-wrap;
      color: var(--text-secondary);
    }
    
    .description-content:empty::before {
      content: 'No description provided';
      color: var(--text-secondary);
      font-style: italic;
    }
    
    /* Files */
    .file-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .file-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .file-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
    }
    
    .file-header:hover {
      background: var(--bg-tertiary);
    }
    
    .file-toggle {
      color: var(--text-secondary);
      font-size: 12px;
      width: 16px;
      transition: transform 0.2s;
    }
    
    .file-item.expanded .file-toggle {
      transform: rotate(90deg);
    }
    
    .file-icon {
      color: var(--text-secondary);
    }
    
    .file-name {
      flex: 1;
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 13px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .file-stats {
      font-size: 12px;
      display: flex;
      gap: 8px;
    }
    
    /* Diff */
    .diff-container {
      display: none;
      border-top: 1px solid var(--border);
      max-height: 500px;
      overflow: auto;
    }
    
    .file-item.expanded .diff-container {
      display: block;
    }
    
    .diff-content {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 12px;
      line-height: 1.4;
    }
    
    .diff-line {
      display: flex;
      white-space: pre;
      min-height: 20px;
    }
    
    .diff-line-num {
      width: 50px;
      padding: 0 8px;
      text-align: right;
      color: var(--text-secondary);
      background: var(--bg-tertiary);
      user-select: none;
      flex-shrink: 0;
    }
    
    .diff-line-content {
      flex: 1;
      padding: 0 12px;
      overflow-x: auto;
    }
    
    .diff-add {
      background: var(--diff-add-bg);
    }
    
    .diff-add .diff-line-content {
      color: var(--diff-add-text);
    }
    
    .diff-del {
      background: var(--diff-del-bg);
    }
    
    .diff-del .diff-line-content {
      color: var(--diff-del-text);
    }
    
    .diff-hunk {
      background: var(--diff-hunk-bg);
    }
    
    .diff-hunk .diff-line-content {
      color: var(--diff-hunk-text);
    }
    
    .diff-hunk .diff-line-num {
      background: var(--diff-hunk-bg);
    }
    
    .no-diff {
      padding: 20px;
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
    }
    
    /* Actions */
    .actions-bar {
      display: flex;
      gap: 12px;
      padding: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      flex-wrap: wrap;
    }
    
    .btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      transition: all 0.2s;
    }
    
    .btn:hover:not(:disabled) {
      background: var(--border);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    
    .btn-primary:hover:not(:disabled) {
      background: var(--accent-hover);
    }
    
    .btn-success {
      background: var(--success);
      border-color: var(--success);
      color: white;
    }
    
    .btn-success:hover:not(:disabled) {
      opacity: 0.9;
    }
    
    /* AI Review */
    .ai-review-section {
      margin-top: 24px;
    }
    
    .ai-status {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .ai-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .ai-results {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .ai-finding {
      display: flex;
      gap: 12px;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    
    .ai-finding-icon {
      font-size: 18px;
      flex-shrink: 0;
    }
    
    .ai-finding-content {
      flex: 1;
    }
    
    .ai-finding-file {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 12px;
      color: var(--accent);
      margin-bottom: 4px;
    }
    
    .ai-finding-message {
      color: var(--text-primary);
    }
    
    .ai-finding.warning {
      border-left: 3px solid var(--warning);
    }
    
    .ai-finding.info {
      border-left: 3px solid var(--accent);
    }
    
    .ai-finding.critical {
      border-left: 3px solid var(--error);
    }
    
    .ai-finding.suggestion {
      border-left: 3px solid var(--accent);
    }
    
    .ai-finding.positive {
      border-left: 3px solid var(--success);
    }
    
    .ai-summary {
      padding: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .ai-summary p {
      margin-top: 8px;
      color: var(--text-secondary);
    }
    
    .ai-verdict {
      font-weight: 600;
      font-size: 15px;
    }
    
    .ai-verdict.approve {
      color: var(--success);
    }
    
    .ai-verdict.request_changes {
      color: var(--warning);
    }
    
    .ai-verdict.comment {
      color: var(--accent);
    }
    
    .ai-section-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin: 16px 0 8px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .ai-finding-suggestion {
      margin-top: 6px;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 12px;
      color: var(--success);
    }
    
    .ai-post-section {
      margin-top: 16px;
      padding: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    
    /* Progress */
    .progress-container {
      padding: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .progress-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .progress-text {
      font-size: 14px;
      color: var(--text-primary);
    }
    
    .progress-percentage {
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .progress-bar-wrapper {
      height: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--success));
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    
    .progress-stages {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    
    .progress-stage {
      flex: 1;
      text-align: center;
      font-size: 11px;
      color: var(--text-secondary);
      padding: 6px 4px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      border: 1px solid transparent;
      transition: all 0.2s;
    }
    
    .progress-stage.active {
      color: var(--accent);
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.1);
    }
    
    .progress-stage.completed {
      color: var(--success);
      border-color: var(--success);
      background: rgba(63, 185, 80, 0.1);
    }
    
    .btn-danger {
      background: var(--error);
      border-color: var(--error);
      color: white;
    }
    
    .btn-danger:hover:not(:disabled) {
      opacity: 0.9;
    }
    
    .btn-warning {
      background: var(--warning);
      border-color: var(--warning);
      color: white;
    }
    
    .btn-warning:hover:not(:disabled) {
      opacity: 0.9;
    }
    
    /* Review action buttons */
    .review-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    
    .review-action-group {
      display: flex;
      gap: 8px;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      align-items: center;
    }
    
    .review-action-label {
      font-size: 13px;
      color: var(--text-secondary);
      margin-right: 8px;
    }
    
    /* Preview section */
    .review-preview {
      margin-top: 16px;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .review-preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
    }
    
    .review-preview-header:hover {
      background: var(--border);
    }
    
    .review-preview-title {
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .review-preview-toggle {
      color: var(--text-secondary);
      transition: transform 0.2s;
    }
    
    .review-preview.expanded .review-preview-toggle {
      transform: rotate(90deg);
    }
    
    .review-preview-content {
      display: none;
      padding: 14px;
      background: var(--bg-secondary);
      max-height: 400px;
      overflow-y: auto;
    }
    
    .review-preview.expanded .review-preview-content {
      display: block;
    }
    
    .review-preview-body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-wrap;
      color: var(--text-primary);
    }
    
    .review-preview-section {
      margin-bottom: 16px;
    }
    
    .review-preview-section-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    
    .review-preview-inline {
      padding: 8px 10px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    .review-preview-inline-file {
      font-family: 'SF Mono', Consolas, monospace;
      color: var(--accent);
      margin-bottom: 4px;
    }
    
    .review-preview-inline-body {
      color: var(--text-primary);
    }
    
    .cancelled-message {
      padding: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      text-align: center;
      color: var(--text-secondary);
    }
    
    /* Loading */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
    }
    
    .loading-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    /* Error */
    .error-message {
      padding: 20px;
      background: var(--diff-del-bg);
      border: 1px solid var(--error);
      border-radius: 8px;
      color: var(--error);
      text-align: center;
    }
    
    /* Inline Comments */
    .inline-comment {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border-left: 3px solid var(--accent);
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
    }
    
    .inline-comment.critical {
      border-left-color: var(--error);
      background: rgba(248, 81, 73, 0.1);
    }
    
    .inline-comment.warning {
      border-left-color: var(--warning);
      background: rgba(210, 153, 34, 0.1);
    }
    
    .inline-comment.info {
      border-left-color: var(--accent);
      background: rgba(88, 166, 255, 0.1);
    }
    
    .inline-comment.invalid {
      opacity: 0.6;
      border-left-color: var(--text-secondary);
    }
    
    .inline-comment-checkbox {
      flex-shrink: 0;
      margin-top: 2px;
    }
    
    .inline-comment-checkbox input {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    
    .inline-comment-content {
      flex: 1;
      min-width: 0;
    }
    
    .inline-comment-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    
    .inline-comment-icon {
      font-size: 14px;
    }
    
    .inline-comment-severity {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .inline-comment-severity.critical { color: var(--error); }
    .inline-comment-severity.warning { color: var(--warning); }
    .inline-comment-severity.info { color: var(--accent); }
    
    .inline-comment-message {
      color: var(--text-primary);
      line-height: 1.4;
    }
    
    .inline-comment-suggestion {
      margin-top: 6px;
      padding: 6px 8px;
      background: var(--bg-secondary);
      border-radius: 4px;
      font-size: 12px;
      color: var(--success);
    }
    
    .inline-comment-warning {
      margin-top: 6px;
      font-size: 11px;
      color: var(--warning);
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    /* Inline comments summary */
    .inline-comments-summary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .inline-comments-summary label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text-primary);
    }
    
    .inline-comments-summary input {
      width: 16px;
      height: 16px;
    }
    
    .inline-comments-count {
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    /* File with comments indicator */
    .file-header .comment-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      background: var(--accent);
      color: white;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="detail-header">
      <button class="back-btn" id="backBtn">
        <span>‚Üê</span>
        <span>Close</span>
      </button>
      <span class="header-title" id="headerTitle">Loading...</span>
      <div class="header-actions">
        <button class="icon-btn" id="openGithubBtn" title="Open in GitHub">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
            <path d="M3.75 2h3.5a.75.75 0 010 1.5H4.5v8h8V8.75a.75.75 0 011.5 0v3.5a.75.75 0 01-.75.75h-9.5a.75.75 0 01-.75-.75v-9.5A.75.75 0 013.75 2z"/>
            <path d="M9.5 2.75a.75.75 0 01.75-.75h3a.75.75 0 01.75.75v3a.75.75 0 01-1.5 0V4.06L8.78 7.78a.75.75 0 01-1.06-1.06l3.72-3.72H9.5a.75.75 0 01-.75-.75z"/>
          </svg>
        </button>
      </div>
    </header>
    
    <div class="detail-content" id="detailContent">
      <div class="loading">
        <div class="loading-spinner"></div>
      </div>
    </div>
  </div>

  <script>
    const API_BASE = 'http://localhost:3847';
    let currentPR = null;
    let reviewPollingInterval = null;
    let currentInlineComments = [];  // Store inline comments from review
    let currentReviewData = null;    // Store the full review data
    
    // Get PR ID from URL
    function getPRIdFromUrl() {
      const params = new URLSearchParams(window.location.search);
      return params.get('id');
    }
    
    // Initialize
    async function init() {
      const prId = getPRIdFromUrl();
      if (!prId) {
        showError('No PR ID provided');
        return;
      }
      
      try {
        const pr = await fetchPRDetails(prId);
        currentPR = pr;
        renderPRDetails(pr);
      } catch (error) {
        console.error('Failed to load PR:', error);
        showError('Failed to load PR details');
      }
    }
    
    // Fetch PR details
    async function fetchPRDetails(prId) {
      const response = await fetch(`${API_BASE}/api/prs/${encodeURIComponent(prId)}`);
      if (!response.ok) throw new Error('Failed to fetch PR');
      return await response.json();
    }
    
    // Render PR details
    function renderPRDetails(pr) {
      document.title = `PR #${pr.number} - ${pr.title}`;
      document.getElementById('headerTitle').textContent = `#${pr.number}: ${pr.title}`;
      
      const content = document.getElementById('detailContent');
      content.innerHTML = `
        <!-- Meta -->
        <div class="detail-meta">
          <img class="meta-avatar" src="${pr.author.avatar_url}" alt="${pr.author.login}" onerror="this.style.display='none'" />
          <span class="meta-author">@${pr.author.login}</span>
          <span class="meta-separator">¬∑</span>
          <span class="meta-repo">${pr.repository.fullName}</span>
          <span class="meta-separator">¬∑</span>
          <span class="meta-time">${formatRelativeTime(new Date(pr.updatedAt))}</span>
          ${pr.labels.length > 0 ? `
            <div class="meta-labels">
              ${pr.labels.map(label => `<span class="label">${escapeHtml(label)}</span>`).join('')}
            </div>
          ` : ''}
        </div>
        
        <!-- Description -->
        <div class="section">
          <h2 class="section-title">Description</h2>
          <div class="description-content">${escapeHtml(pr.body || '')}</div>
        </div>
        
        <!-- Files -->
        <div class="section">
          <h2 class="section-title">
            Files Changed
            <span class="section-stats">
              (${pr.files?.length || 0})
              <span class="stats-add">+${pr.stats.additions}</span>
              <span class="stats-del">-${pr.stats.deletions}</span>
            </span>
          </h2>
          <div class="file-list" id="fileList">
            ${renderFileList(pr.files || [])}
          </div>
        </div>
        
        <!-- Actions -->
        <div class="section">
          <div class="actions-bar">
            <button class="btn btn-primary" id="aiReviewBtn">
              <span>ü§ñ</span>
              <span>Start AI Review</span>
            </button>
            <button class="btn btn-success" id="markReviewedBtn">
              <span>‚úì</span>
              <span>Mark as Reviewed</span>
            </button>
            <button class="btn" id="openInGithubBtn">
              <span>‚Üó</span>
              <span>Open in GitHub</span>
            </button>
          </div>
        </div>
        
        <!-- AI Review Section -->
        <div class="section ai-review-section" id="aiReviewSection" style="display: none;">
          <h2 class="section-title">AI Review</h2>
          <div id="aiReviewContent"></div>
        </div>
      `;
      
      // Setup event listeners
      setupEventListeners(pr);
      
      // Setup file toggles
      setupFileToggles();
      
      // Check for existing review
      checkExistingReview(pr.id);
    }
    
    // Render file list with optional inline comments
    function renderFileList(files, inlineComments = []) {
      if (!files || files.length === 0) {
        return '<div class="no-diff">No files changed</div>';
      }
      
      // Get files that have comments
      const filesWithComments = new Set(inlineComments.map(c => c.file));
      
      return files.map((file, index) => {
        const hasComments = filesWithComments.has(file.filename);
        const commentCount = inlineComments.filter(c => c.file === file.filename).length;
        // Auto-expand first file OR files with comments
        const shouldExpand = index === 0 || hasComments;
        
        return `
          <div class="file-item ${shouldExpand ? 'expanded' : ''}" data-file="${escapeHtml(file.filename)}">
            <div class="file-header">
              <span class="file-toggle">‚ñ∂</span>
              <span class="file-icon">üìÑ</span>
              <span class="file-name">${escapeHtml(file.filename)}</span>
              ${hasComments ? `<span class="comment-indicator">üí¨ ${commentCount}</span>` : ''}
              <span class="file-stats">
                <span class="stats-add">+${file.additions}</span>
                <span class="stats-del">-${file.deletions}</span>
              </span>
            </div>
            <div class="diff-container">
              ${renderDiff(file.patch, file.filename, inlineComments)}
            </div>
          </div>
        `;
      }).join('');
    }
    
    // Render diff with optional inline comments
    function renderDiff(patch, filename, inlineComments = []) {
      if (!patch) {
        return '<div class="no-diff">Binary file or no diff available</div>';
      }
      
      // Get comments for this file, grouped by actualLine
      const commentsByLine = {};
      inlineComments
        .filter(c => c.file === filename)
        .forEach(c => {
          if (!commentsByLine[c.actualLine]) commentsByLine[c.actualLine] = [];
          commentsByLine[c.actualLine].push(c);
        });
      
      const lines = patch.split('\n');
      let oldLine = 0;
      let newLine = 0;
      
      const html = lines.map(line => {
        let className = 'diff-line';
        let lineNum = '';
        let currentLineNum = 0;
        
        if (line.startsWith('@@')) {
          const match = line.match(/@@ -(\d+),?\d* \+(\d+),?\d* @@/);
          if (match) {
            oldLine = parseInt(match[1], 10);
            newLine = parseInt(match[2], 10);
          }
          className += ' diff-hunk';
          lineNum = '...';
        } else if (line.startsWith('+') && !line.startsWith('+++')) {
          className += ' diff-add';
          currentLineNum = newLine;
          lineNum = newLine++;
        } else if (line.startsWith('-') && !line.startsWith('---')) {
          className += ' diff-del';
          lineNum = oldLine++;
        } else if (!line.startsWith('\\')) {
          currentLineNum = newLine;
          lineNum = newLine++;
          oldLine++;
        }
        
        let result = `
          <div class="${className}" data-line="${currentLineNum}">
            <span class="diff-line-num">${lineNum}</span>
            <span class="diff-line-content">${escapeHtml(line)}</span>
          </div>
        `;
        
        // Add inline comments after this line
        if (commentsByLine[currentLineNum]) {
          commentsByLine[currentLineNum].forEach(comment => {
            result += renderInlineComment(comment);
          });
        }
        
        return result;
      }).join('');
      
      return `<div class="diff-content">${html}</div>`;
    }
    
    // Render a single inline comment
    function renderInlineComment(comment) {
      const severity = comment.issue.severity || 'info';
      const icon = severity === 'critical' ? 'üî¥' : severity === 'warning' ? 'üü†' : 'üü°';
      const isValid = comment.isValid;
      const checked = comment.selected ? 'checked' : '';
      
      return `
        <div class="inline-comment ${severity} ${isValid ? '' : 'invalid'}" data-index="${comment.issueIndex}">
          <label class="inline-comment-checkbox">
            <input type="checkbox" ${checked} onchange="toggleInlineComment(${comment.issueIndex}, this.checked)">
          </label>
          <div class="inline-comment-content">
            <div class="inline-comment-header">
              <span class="inline-comment-icon">${icon}</span>
              <span class="inline-comment-severity ${severity}">${severity}</span>
            </div>
            <div class="inline-comment-message">${escapeHtml(comment.issue.message)}</div>
            ${comment.issue.suggestion ? `<div class="inline-comment-suggestion">üí° ${escapeHtml(comment.issue.suggestion)}</div>` : ''}
            ${comment.warning ? `<div class="inline-comment-warning">‚ö†Ô∏è ${escapeHtml(comment.warning)}</div>` : ''}
          </div>
        </div>
      `;
    }
    
    // Toggle inline comment selection
    function toggleInlineComment(index, selected) {
      if (currentInlineComments[index]) {
        currentInlineComments[index].selected = selected;
        updatePostButtonText();
        updateSelectAllCheckbox();
        updatePreview();
      }
    }
    
    // Toggle all inline comments
    function toggleAllInlineComments(selected) {
      currentInlineComments.forEach(c => {
        if (c.isValid) c.selected = selected;
      });
      // Update all checkboxes in the UI
      document.querySelectorAll('.inline-comment input[type="checkbox"]').forEach(cb => {
        const index = parseInt(cb.closest('.inline-comment').dataset.index);
        const comment = currentInlineComments[index];
        if (comment && comment.isValid) {
          cb.checked = selected;
        }
      });
      updatePostButtonText();
      updatePreview();
    }
    
    // Update the post button text with count
    function updatePostButtonText() {
      const selectedCount = currentInlineComments.filter(c => c.selected && c.isValid).length;
      
      // Update inline count text below action buttons
      const inlineCountText = document.getElementById('inlineCountText');
      if (inlineCountText) {
        inlineCountText.textContent = selectedCount > 0 
          ? `Will include ${selectedCount} inline comment${selectedCount > 1 ? 's' : ''}`
          : 'No inline comments selected';
      }
    }
    
    // Update select all checkbox state
    function updateSelectAllCheckbox() {
      const selectAllCb = document.getElementById('selectAllComments');
      if (!selectAllCb) return;
      
      const validComments = currentInlineComments.filter(c => c.isValid);
      const selectedCount = validComments.filter(c => c.selected).length;
      
      selectAllCb.checked = selectedCount === validComments.length && validComments.length > 0;
      selectAllCb.indeterminate = selectedCount > 0 && selectedCount < validComments.length;
    }
    
    // Format review body for preview (mirrors reviewPoster.ts formatStandardReview)
    function formatReviewPreview(review) {
      if (!review) return 'No review data available';
      
      const sections = ['## Code Review\n', `### Summary\n${review.summary || 'No summary'}\n`];
      
      const issues = review.issues || [];
      if (issues.length > 0) {
        sections.push('### Issues\n' + formatIssuesBySeverityPreview(issues));
      }
      
      const suggestions = review.suggestions || [];
      if (suggestions.length > 0) {
        sections.push('### Suggestions\n');
        suggestions.forEach(s => sections.push(`- ${s.message || s}`));
      }
      
      const verdict = review.verdict || 'comment';
      const verdictText = verdict === 'approve' 
        ? '**Verdict:** ‚úÖ Looks good to merge!'
        : verdict === 'request_changes'
          ? '**Verdict:** ‚ö†Ô∏è Please address the issues above.'
          : '**Verdict:** üí¨ Review complete.';
      
      sections.push('\n---\n' + verdictText);
      sections.push('\n\n---\n*Assisted by AI review*');
      
      return sections.join('\n');
    }
    
    // Format issues grouped by severity for preview
    function formatIssuesBySeverityPreview(issues) {
      const critical = issues.filter(i => i.severity === 'critical');
      const warning = issues.filter(i => i.severity === 'warning');
      const infoIssues = issues.filter(i => i.severity === 'info');
      
      const parts = [];
      
      if (critical.length > 0) {
        parts.push(`**üî¥ Critical (${critical.length})**\n`);
        critical.forEach(i => parts.push(formatIssueItemPreview(i)));
      }
      
      if (warning.length > 0) {
        parts.push(`\n**üü† Needs Attention (${warning.length})**\n`);
        warning.forEach(i => parts.push(formatIssueItemPreview(i)));
      }
      
      if (infoIssues.length > 0) {
        parts.push(`\n**üü° Info (${infoIssues.length})**\n`);
        infoIssues.forEach(i => parts.push(formatIssueItemPreview(i)));
      }
      
      return parts.join('');
    }
    
    // Format a single issue for preview
    function formatIssueItemPreview(issue) {
      const loc = issue.file ? `\`${issue.file}${issue.line ? ':' + issue.line : ''}\`` : '';
      return `- ${loc} - ${issue.message}\n`;
    }
    
    // Render selected inline comments for preview
    function renderSelectedInlineCommentsPreview() {
      const selected = currentInlineComments.filter(c => c.selected && c.isValid);
      
      if (selected.length === 0) {
        return '<p style="color: var(--text-secondary); font-style: italic;">No inline comments selected</p>';
      }
      
      return selected.map(c => {
        const emoji = c.issue.severity === 'critical' ? 'üî¥' : c.issue.severity === 'warning' ? 'üü†' : 'üü°';
        const label = c.issue.severity === 'critical' ? 'Critical' : c.issue.severity === 'warning' ? 'Warning' : 'Info';
        
        return `
          <div class="review-preview-inline">
            <div class="review-preview-inline-file">${escapeHtml(c.file)}:${c.actualLine}</div>
            <div class="review-preview-inline-body">${emoji} <strong>${label}:</strong> ${escapeHtml(c.issue.message)}${c.issue.suggestion ? `<br><em>Suggestion: ${escapeHtml(c.issue.suggestion)}</em>` : ''}</div>
          </div>
        `;
      }).join('');
    }
    
    // Toggle preview expand/collapse
    function togglePreview() {
      const preview = document.getElementById('reviewPreview');
      if (preview) {
        preview.classList.toggle('expanded');
      }
    }
    
    // Update preview content (call when selections change)
    function updatePreview() {
      const previewBody = document.getElementById('previewBody');
      const previewInline = document.getElementById('previewInline');
      const previewInlineCount = document.getElementById('previewInlineCount');
      
      if (previewBody && currentReviewData?.result?.output) {
        previewBody.textContent = formatReviewPreview(currentReviewData.result.output);
      }
      
      if (previewInline) {
        previewInline.innerHTML = renderSelectedInlineCommentsPreview();
      }
      
      if (previewInlineCount) {
        const selectedCount = currentInlineComments.filter(c => c.selected && c.isValid).length;
        previewInlineCount.textContent = selectedCount > 0 
          ? `${selectedCount} inline comment${selectedCount > 1 ? 's' : ''} will be posted`
          : 'No inline comments selected';
      }
    }
    
    // Setup event listeners
    function setupEventListeners(pr) {
      document.getElementById('backBtn').addEventListener('click', closeAndShowMenubar);
      document.getElementById('openGithubBtn').addEventListener('click', () => openExternal(pr.htmlUrl));
      document.getElementById('openInGithubBtn').addEventListener('click', () => openExternal(pr.htmlUrl));
      document.getElementById('aiReviewBtn').addEventListener('click', () => startAIReview(pr.id));
      document.getElementById('markReviewedBtn').addEventListener('click', () => markAsReviewed(pr.id));
    }
    
    // Setup file toggles
    function setupFileToggles() {
      document.querySelectorAll('.file-header').forEach(header => {
        header.addEventListener('click', () => {
          const fileItem = header.parentElement;
          fileItem.classList.toggle('expanded');
        });
      });
    }
    
    // Close window and show menubar
    function closeAndShowMenubar() {
      if (window.electronAPI?.closeAndShowMenubar) {
        window.electronAPI.closeAndShowMenubar();
      } else {
        window.close();
      }
    }
    
    // Open external URL
    function openExternal(url) {
      if (window.electronAPI?.openExternal) {
        window.electronAPI.openExternal(url);
      } else {
        window.open(url, '_blank');
      }
    }
    
    // Stage labels for display
    const STAGE_LABELS = {
      starting: 'Starting',
      fetching_diff: 'Fetching Diff',
      analyzing: 'Analyzing Code',
      generating: 'Generating Review',
      parsing: 'Processing Results'
    };
    
    const STAGES = ['starting', 'fetching_diff', 'analyzing', 'generating', 'parsing'];
    
    // Start AI Review
    async function startAIReview(prId) {
      const btn = document.getElementById('aiReviewBtn');
      btn.disabled = true;
      btn.innerHTML = '<span class="ai-spinner"></span><span>Starting...</span>';
      
      const section = document.getElementById('aiReviewSection');
      section.style.display = 'block';
      
      const content = document.getElementById('aiReviewContent');
      renderProgressUI(content, 'starting', 10, prId);
      
      try {
        const response = await fetch(`${API_BASE}/api/review/${encodeURIComponent(prId)}`, {
          method: 'POST'
        });
        
        if (!response.ok) {
          throw new Error('Failed to start review');
        }
        
        // Start polling for status
        pollReviewStatus(prId);
      } catch (error) {
        console.error('Failed to start AI review:', error);
        content.innerHTML = `
          <div class="error-message">
            Failed to start AI review. Make sure OpenCode is installed and configured.
          </div>
        `;
        btn.disabled = false;
        btn.innerHTML = '<span>ü§ñ</span><span>Retry AI Review</span>';
      }
    }
    
    // Render progress UI with stages and stop button
    function renderProgressUI(container, stage, progress, prId) {
      const stageLabel = STAGE_LABELS[stage] || 'Processing';
      
      container.innerHTML = `
        <div class="progress-container">
          <div class="progress-header">
            <div class="progress-status">
              <div class="ai-spinner"></div>
              <span class="progress-text">${stageLabel}...</span>
            </div>
            <span class="progress-percentage">${progress}%</span>
          </div>
          
          <div class="progress-bar-wrapper">
            <div class="progress-bar" style="width: ${progress}%"></div>
          </div>
          
          <div class="progress-stages">
            ${STAGES.map(s => {
              const stageIdx = STAGES.indexOf(s);
              const currentIdx = STAGES.indexOf(stage);
              let stageClass = '';
              if (stageIdx < currentIdx) stageClass = 'completed';
              else if (stageIdx === currentIdx) stageClass = 'active';
              return `<div class="progress-stage ${stageClass}">${STAGE_LABELS[s]}</div>`;
            }).join('')}
          </div>
        </div>
        
        <button class="btn btn-danger" id="stopReviewBtn">
          <span>‚èπ</span>
          <span>Stop Review</span>
        </button>
      `;
      
      document.getElementById('stopReviewBtn').addEventListener('click', () => cancelAIReview(prId));
    }
    
    // Cancel AI Review
    async function cancelAIReview(prId) {
      const stopBtn = document.getElementById('stopReviewBtn');
      if (stopBtn) {
        stopBtn.disabled = true;
        stopBtn.innerHTML = '<span class="ai-spinner"></span><span>Stopping...</span>';
      }
      
      try {
        await fetch(`${API_BASE}/api/review/${encodeURIComponent(prId)}/cancel`, {
          method: 'POST'
        });
        
        if (reviewPollingInterval) {
          clearInterval(reviewPollingInterval);
          reviewPollingInterval = null;
        }
        
        const content = document.getElementById('aiReviewContent');
        content.innerHTML = `
          <div class="cancelled-message">
            Review was cancelled.
          </div>
        `;
        
        resetAIButton();
      } catch (error) {
        console.error('Failed to cancel review:', error);
        if (stopBtn) {
          stopBtn.disabled = false;
          stopBtn.innerHTML = '<span>‚èπ</span><span>Stop Review</span>';
        }
      }
    }
    
    // Poll review status
    function pollReviewStatus(prId) {
      if (reviewPollingInterval) {
        clearInterval(reviewPollingInterval);
      }
      
      const content = document.getElementById('aiReviewContent');
      
      reviewPollingInterval = setInterval(async () => {
        try {
          const response = await fetch(`${API_BASE}/api/review/${encodeURIComponent(prId)}`);
          const review = await response.json();
          
          if (review.status === 'completed') {
            clearInterval(reviewPollingInterval);
            reviewPollingInterval = null;
            renderAIResults(review);
          } else if (review.status === 'failed') {
            clearInterval(reviewPollingInterval);
            reviewPollingInterval = null;
            content.innerHTML = `
              <div class="error-message">
                AI review failed: ${escapeHtml(review.error || 'Unknown error')}
              </div>
            `;
            resetAIButton();
          } else if (review.status === 'cancelled') {
            clearInterval(reviewPollingInterval);
            reviewPollingInterval = null;
            content.innerHTML = `
              <div class="cancelled-message">
                Review was cancelled.
              </div>
            `;
            resetAIButton();
          } else if (review.status === 'in_progress') {
            const stage = review.stage || 'analyzing';
            const progress = review.progress || 50;
            renderProgressUI(content, stage, progress, prId);
          }
        } catch (error) {
          console.error('Failed to poll review status:', error);
        }
      }, 1000);
    }
    
    // Render AI results
    function renderAIResults(review) {
      const content = document.getElementById('aiReviewContent');
      
      // Store review data and inline comments
      currentReviewData = review;
      currentInlineComments = review.inlineComments || [];
      
      // Extract data from review state structure
      const output = review.result?.output || {};
      const summary = output.summary || 'Review completed';
      const verdict = output.verdict || 'comment';
      const issues = output.issues || [];
      const suggestions = output.suggestions || [];
      const positives = output.positives || [];
      
      const validInlineCount = currentInlineComments.filter(c => c.isValid).length;
      const selectedInlineCount = currentInlineComments.filter(c => c.selected && c.isValid).length;
      
      console.log('[AI Review] Rendering results:', { 
        summary, verdict, 
        issues: issues.length, 
        suggestions: suggestions.length,
        inlineComments: currentInlineComments.length,
        validInline: validInlineCount
      });
      
      // Build the results HTML
      let html = `
        <div class="ai-summary">
          <div class="ai-verdict ${verdict}">
            ${verdict === 'approve' ? '‚úÖ Approved' : verdict === 'request_changes' ? '‚ö†Ô∏è Changes Requested' : 'üí¨ Comment'}
          </div>
          <p>${escapeHtml(summary)}</p>
        </div>
      `;
      
      // Inline comments summary with select all
      if (currentInlineComments.length > 0) {
        html += `
          <div class="inline-comments-summary">
            <label>
              <input type="checkbox" id="selectAllComments" ${selectedInlineCount === validInlineCount ? 'checked' : ''} onchange="toggleAllInlineComments(this.checked)">
              <span>Select all inline comments</span>
            </label>
            <span class="inline-comments-count">${validInlineCount} valid, ${currentInlineComments.length - validInlineCount} invalid</span>
          </div>
        `;
      }
      
      // Show non-inline issues (those without file/line)
      const nonInlineIssues = issues.filter(i => !i.file || !i.line);
      if (nonInlineIssues.length > 0) {
        html += `<div class="ai-section-title">General Issues (${nonInlineIssues.length})</div>`;
        html += `<div class="ai-results">`;
        nonInlineIssues.forEach(issue => {
          const severity = issue.severity || 'info';
          const icon = severity === 'critical' ? 'üî¥' : severity === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
          html += `
            <div class="ai-finding ${severity}">
              <span class="ai-finding-icon">${icon}</span>
              <div class="ai-finding-content">
                <div class="ai-finding-message">${escapeHtml(issue.message)}</div>
                ${issue.suggestion ? `<div class="ai-finding-suggestion">‚Üí ${escapeHtml(issue.suggestion)}</div>` : ''}
              </div>
            </div>
          `;
        });
        html += `</div>`;
      }
      
      // Show suggestions
      if (suggestions.length > 0) {
        html += `<div class="ai-section-title">Suggestions (${suggestions.length})</div>`;
        html += `<div class="ai-results">`;
        suggestions.forEach(sug => {
          html += `
            <div class="ai-finding suggestion">
              <span class="ai-finding-icon">üí°</span>
              <div class="ai-finding-content">
                ${sug.file ? `<div class="ai-finding-file">${escapeHtml(sug.file)}${sug.line ? ':' + sug.line : ''}</div>` : ''}
                <div class="ai-finding-message">${escapeHtml(sug.message)}</div>
              </div>
            </div>
          `;
        });
        html += `</div>`;
      }
      
      // Show positives
      if (positives.length > 0) {
        html += `<div class="ai-section-title">Positives (${positives.length})</div>`;
        html += `<div class="ai-results">`;
        positives.forEach(pos => {
          html += `
            <div class="ai-finding positive">
              <span class="ai-finding-icon">‚úÖ</span>
              <div class="ai-finding-content">
                <div class="ai-finding-message">${escapeHtml(pos)}</div>
              </div>
            </div>
          `;
        });
        html += `</div>`;
      }
      
      // No issues message
      if (issues.length === 0 && suggestions.length === 0) {
        html += `
          <div class="ai-finding positive">
            <span class="ai-finding-icon">‚úÖ</span>
            <div class="ai-finding-content">
              <div class="ai-finding-message">No issues found. The code looks good!</div>
            </div>
          </div>
        `;
      }
      
      // Review preview section
      html += `
        <div class="review-preview" id="reviewPreview">
          <div class="review-preview-header" onclick="togglePreview()">
            <span class="review-preview-title">üìù Preview what will be posted</span>
            <span class="review-preview-toggle">‚ñ∂</span>
          </div>
          <div class="review-preview-content">
            <div class="review-preview-section">
              <div class="review-preview-section-title">Main Review Body</div>
              <pre class="review-preview-body" id="previewBody">${escapeHtml(formatReviewPreview(output))}</pre>
            </div>
            <div class="review-preview-section">
              <div class="review-preview-section-title">Inline Comments <span id="previewInlineCount" style="font-weight: normal;">(${selectedInlineCount > 0 ? selectedInlineCount + ' selected' : 'none selected'})</span></div>
              <div id="previewInline">${renderSelectedInlineCommentsPreview()}</div>
            </div>
          </div>
        </div>
      `;
      
      // Post review buttons with action selection
      html += `
        <div class="ai-post-section">
          <div class="review-action-group">
            <span class="review-action-label">Post as:</span>
            <button class="btn btn-success" id="approveBtn" title="Approve this PR">
              <span>‚úÖ</span>
              <span>Approve</span>
            </button>
            <button class="btn btn-warning" id="requestChangesBtn" title="Request changes">
              <span>‚ö†Ô∏è</span>
              <span>Request Changes</span>
            </button>
            <button class="btn btn-primary" id="commentBtn" title="Post as comment only">
              <span>üí¨</span>
              <span>Comment</span>
            </button>
          </div>
          <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;" id="inlineCountText">
            ${selectedInlineCount > 0 ? `Will include ${selectedInlineCount} inline comment${selectedInlineCount > 1 ? 's' : ''}` : 'No inline comments selected'}
          </p>
        </div>
      `;
      
      content.innerHTML = html;
      
      // Re-render file list with inline comments
      if (currentInlineComments.length > 0 && currentPR?.files) {
        const fileList = document.getElementById('fileList');
        if (fileList) {
          fileList.innerHTML = renderFileList(currentPR.files, currentInlineComments);
          setupFileToggles();
        }
      }
      
      // Add event listeners for review action buttons
      document.getElementById('approveBtn')?.addEventListener('click', () => postReviewToGitHub(currentPR.id, 'APPROVE'));
      document.getElementById('requestChangesBtn')?.addEventListener('click', () => postReviewToGitHub(currentPR.id, 'REQUEST_CHANGES'));
      document.getElementById('commentBtn')?.addEventListener('click', () => postReviewToGitHub(currentPR.id, 'COMMENT'));
      
      resetAIButton();
    }
    
    // Reset AI button
    function resetAIButton() {
      const btn = document.getElementById('aiReviewBtn');
      btn.disabled = false;
      btn.innerHTML = '<span>ü§ñ</span><span>Re-run AI Review</span>';
    }
    
    // Post review to GitHub
    async function postReviewToGitHub(prId, action = 'COMMENT') {
      // Disable all action buttons
      const approveBtn = document.getElementById('approveBtn');
      const requestChangesBtn = document.getElementById('requestChangesBtn');
      const commentBtn = document.getElementById('commentBtn');
      
      const buttons = [approveBtn, requestChangesBtn, commentBtn].filter(Boolean);
      buttons.forEach(btn => btn.disabled = true);
      
      // Show loading on clicked button
      const actionBtn = action === 'APPROVE' ? approveBtn : action === 'REQUEST_CHANGES' ? requestChangesBtn : commentBtn;
      const originalHtml = actionBtn?.innerHTML;
      if (actionBtn) {
        actionBtn.innerHTML = '<span class="ai-spinner"></span><span>Posting...</span>';
      }
      
      try {
        // Build the request body with inline comments
        const selectedIndices = currentInlineComments
          .map((c, i) => c.selected ? i : -1)
          .filter(i => i >= 0);
        
        const hasInlineComments = selectedIndices.length > 0;
        
        const requestBody = {
          prId,
          review: currentReviewData?.result?.output || {},
          action: action,
          formatOptions: {
            style: 'standard',
            attribution: 'subtle'
          },
          includeInlineComments: hasInlineComments,
          selectedCommentIndices: selectedIndices
        };
        
        console.log('[Post Review] Request:', {
          prId,
          action: action,
          inlineComments: selectedIndices.length,
          totalComments: currentInlineComments.length
        });
        
        const response = await fetch(`${API_BASE}/api/review/${encodeURIComponent(prId)}/post`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          throw new Error(error.error || 'Failed to post review');
        }
        
        const result = await response.json();
        console.log('[Post Review] Success:', result);
        
        // Show success state
        const actionLabel = action === 'APPROVE' ? 'Approved' : action === 'REQUEST_CHANGES' ? 'Changes Requested' : 'Commented';
        const inlineMsg = hasInlineComments ? ` (${selectedIndices.length} inline)` : '';
        
        if (actionBtn) {
          actionBtn.innerHTML = `<span>‚úÖ</span><span>${actionLabel}${inlineMsg}</span>`;
          actionBtn.classList.add('btn-success');
          actionBtn.classList.remove('btn-primary', 'btn-warning');
        }
        
        // Keep other buttons disabled
      } catch (error) {
        console.error('Failed to post review:', error);
        // Re-enable buttons on error
        buttons.forEach(btn => btn.disabled = false);
        if (actionBtn) {
          actionBtn.innerHTML = originalHtml;
        }
        alert('Failed to post review: ' + error.message);
      }
    }
    
    // Mark as reviewed
    async function markAsReviewed(prId) {
      const btn = document.getElementById('markReviewedBtn');
      btn.disabled = true;
      
      try {
        await fetch(`${API_BASE}/api/prs/${encodeURIComponent(prId)}/reviewed`, {
          method: 'POST'
        });
        btn.innerHTML = '<span>‚úì</span><span>Marked as Reviewed</span>';
      } catch (error) {
        console.error('Failed to mark as reviewed:', error);
        btn.disabled = false;
      }
    }
    
    // Check for existing review
    async function checkExistingReview(prId) {
      try {
        const response = await fetch(`${API_BASE}/api/review/${encodeURIComponent(prId)}`);
        if (response.ok) {
          const review = await response.json();
          if (review && review.status === 'completed') {
            document.getElementById('aiReviewSection').style.display = 'block';
            renderAIResults(review);
          }
        }
      } catch (error) {
        // No existing review, that's fine
      }
    }
    
    // Show error
    function showError(message) {
      document.getElementById('detailContent').innerHTML = `
        <div class="error-message">${escapeHtml(message)}</div>
      `;
    }
    
    // Escape HTML
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Format relative time
    function formatRelativeTime(date) {
      const now = new Date();
      const diff = now - date;
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      
      if (days > 0) return `${days}d ago`;
      if (hours > 0) return `${hours}h ago`;
      if (minutes > 0) return `${minutes}m ago`;
      return 'just now';
    }
    
    // Initialize on load
    init();
    
    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (reviewPollingInterval) {
        clearInterval(reviewPollingInterval);
      }
    });
  </script>
</body>
</html>
